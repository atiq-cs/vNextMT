// Copyright (c) FFTSys Inc. All rights reserved.
// Use of this source code is governed by a GPL-v3 license

namespace Parser {
  using System;
  using System.Text;
  using System.Collections.Generic;

  /// <summary>
  /// Parser
  /// 
  /// </summary>
  class Parser {
    // Whether to skip experimental rules
    private bool ShouldSkipExpRule {get; set;}
    // Input string containing all Quark Rules (Legacy)
    private string RawStr {get; set;}
    // Starting tag string of a rule
    // Just use appSettings variable directly instead
    private JsonKV VerticalSettings;

    // Indicates where current Rule String starts
    private int Pos { get; set; }
    private HashSet<string> ImportRefs { get; set; }

    private bool IsFirst;

    // parser helper tags: common across verticals
    private string QuoteTail {get; set;}
    private string ParenthesisTail {get; set;}
    private string TripleQuotes {get; set;}
    private string FStringHead {get; set;}
    private string RankingPlatform {get; set;}

    /// <summary>
    /// Constructor: init class members
    /// </summary>
    public Parser(string str, JsonKV verticalSettings, bool shouldFilterExpRules = true) {
      RawStr = str;
      Pos = 0;

      VerticalSettings = verticalSettings;

      ShouldSkipExpRule = shouldFilterExpRules;
      IsFirst = true;

      ImportRefs = new HashSet<string>();

      QuoteTail = "\",";
      ParenthesisTail = "),";
      TripleQuotes = "\"\"\"";
      FStringHead = "f" + TripleQuotes;

      RankingPlatform = VerticalSettings.Vertical == "wpr" ? "blender": "twiddler";
    }

    private bool ContainsDoNotFilterExpRule(string haystack) {
      if (VerticalSettings.IncludeExpRules == null)
        return false;
      foreach (var configName in VerticalSettings.IncludeExpRules)
        if (haystack.Contains(configName)) {
          // Debug if this hit
          // Console.WriteLine("True for "+ configName);
          return true;
        }
      return false;
    }

    /// <summary>
    /// Verify if we have next rule
    /// </summary>
    /// <returns>
    /// Return true if next rule is available
    /// If parser reached EOF or got past all rules returns false
    /// </returns>
    /* public bool HasNext() {
      return rawStr.IndexOf(headStr, pos, rawStr.Length-pos) > 0;
    } */

    /// <summary>
    /// Get Next Rule as string
    /// Utilize position variable to find where the current rule is at.
    ///  - Start the rule from that index
    ///  - End the rule at next rule's found index
    /// </summary>
    /// <remarks>
    /// Filters enabled,
    /// - Experimental Rules
    /// - 'fuss_limited_discoverable' rules
    /// </remarks>
    /// <returns>
    /// Returns Empty string if no next rule found
    /// </returns>
    public string GetNextRule(bool isAutoGeneratedRuleFile = false) {
      if (IsFirst) {
        IsFirst = false;
        GetNextRuleMain();
      }

      var ruleStr = GetNextRuleMain();
      if (!ShouldSkipExpRule)
        return ruleStr;


      while ((ruleStr != string.Empty))
      {
        bool shouldFilter = false;
        // to filter stuffs like fuss ld
        foreach(var filter in VerticalSettings.Filters)
          if (ruleStr.Contains(filter)) {
            shouldFilter = true;
            break;
          }

        var isMultiSurface = false;
        if (VerticalSettings.Vertical == "public_posts" || VerticalSettings.Vertical == "deep_dive")
          isMultiSurface = true;

        var haystack = ruleStr;

        if (!shouldFilter && isMultiSurface) {
          if (isAutoGeneratedRuleFile) {
            var surface = (VerticalSettings.Vertical == "deep_dive") ? "DEEP_DIVE" : "SERP";
            var surfaceHead = "surfaces=[";
            var surfaceStr = $"SurfaceType.{surface}";
            bool hasSurfacehead = ruleStr.Contains(surfaceHead);
            bool hasSurfstr = ruleStr.Contains(surfaceStr);

            // default surface is SERP
            if (!hasSurfacehead && surface == "DEEP_DIVE")
              shouldFilter=true;
            // has non default surface, but doesn't not mention intended one
            else if (hasSurfacehead && !hasSurfstr)
              shouldFilter=true;
          }
          else {
            var surface = (VerticalSettings.Vertical == "deep_dive") ? "DEEP_DIVE" : "PUBLIC_POSTS";
            var multiSurfHaystack = ruleStr;
            var surfaceHead = $"SurfaceType.{surface}: QuarkImpl(";
            var surfaceTail = ')';

            // Start surface and end Surface are indices
            int startS = multiSurfHaystack.IndexOf(surfaceHead) + surfaceHead.Length;
            if (startS == (surfaceHead.Length-1)) {
              shouldFilter = true;
            }
            else {
              int endS = multiSurfHaystack.IndexOf(surfaceTail, startS + 1, multiSurfHaystack.Length-startS-1);
              if (endS == -1)
                throw new System.IO.InvalidDataException($"Ending marker: {surfaceTail} not found in {multiSurfHaystack}!");

              var surfaceHaystack = multiSurfHaystack.Substring(startS, endS-startS);
              haystack = surfaceHaystack;
            }
          }
        }

        /// Other verticals can also include Exp rules as per demand
        if (!shouldFilter && !isAutoGeneratedRuleFile) {
          var status = GetFieldValue(haystack, "status=");
          bool isExp = (status == "Status.EXP");
          if (isExp && !ContainsDoNotFilterExpRule(ruleStr))
            shouldFilter = true;
        }

        if (shouldFilter)
          ruleStr = GetNextRuleMain();
        else
          break;
      }

      return ruleStr;
    }


    public string GetNextRuleMain() {
      var HeadStr = VerticalSettings.HeadTag;
      var TailStr = VerticalSettings.TailTag;

      int prev = Pos;
      int current = RawStr.IndexOf(HeadStr, Pos + HeadStr.Length, RawStr.Length-Pos-HeadStr.Length);
      if (current == -1) {
        // Usually we have a segment before Rules start, assuming it's more than 50 chars
        if (Pos < 50)
          return string.Empty;

        // Need the tail Str to find last Rule
        current = RawStr.IndexOf(TailStr, Pos + TailStr.Length, RawStr.Length-Pos-TailStr.Length);
        if (current == -1)
          return string.Empty;

        if (RawStr.Substring(prev, current-prev).Contains("featureNameToValue("))
          current = RawStr.IndexOf(TailStr, current + 1, RawStr.Length-current-1);
      }

      Pos = current;

      if (Pos <= prev)
        throw new System.IO.InvalidDataException($"Tag: {HeadStr} not found!");

      return RawStr.Substring(prev, Pos-prev);
    }

    /// <summary>
    /// Convert messy name to Uniform name
    /// rules to convert:
    /// 1. Prefixes
    ///  - "rule__integrity_" manually cleaned up in input file
    /// 2. Suffixes
    ///  "_via_wpr_in_quark"
    /// </summary>
    /// <remarks>
    /// Currently, tuned for WPR Rules
    /// cleans up some common substrings
    /// </remarks>
    private string ConvertToUniformName(string messy) {
      // Prefixes
      var cleanPrefix = messy;

      var tinyStr = "rule__";
      if (cleanPrefix.StartsWith(tinyStr))
        cleanPrefix = cleanPrefix.Substring(tinyStr.Length, cleanPrefix.Length-tinyStr.Length);  
    
      // Suffixes
      // some followd by _v2 and _exp. Hence, Replace instead of Substring
      var cleanSuffix = cleanPrefix.Replace("_via_wpr_in_quark", "");
      // some followd by _exp. Hence, Replace instead of Substring
      cleanSuffix = cleanSuffix.Replace("_wpr_quark", "");
      cleanSuffix = cleanSuffix.Replace("_in_wpr", "");
      tinyStr = "_wpr";
      if (cleanSuffix.EndsWith(tinyStr))
        cleanSuffix = cleanSuffix.Substring(0, cleanSuffix.Length-tinyStr.Length);

      // At this point, cleanSuffix has both Prefix and Suffix cleaned up


      return cleanSuffix;
    }

    private string GetIntegrityEnforcementStr(string haystack) {
      var EnfType = GetFieldValue(haystack, "enforcement_type=");
      var enfStr = EnfType switch {
        "IntegrityEnforcementType.PUSH_BOTTOM" => "demote",
        "IntegrityEnforcementType.BLOCKLIST" => "block",
        "IntegrityEnforcementType.BRING_TOP" => "boost",
        "IntegrityEnforcementType.ADDITIVE_DEMOTION" => "CUSTOM",
        _ => string.Empty,
      };

      if (enfStr == "CUSTOM") {
        // TODO: optimize later
        var opStr = string.Empty;

        if (haystack.Contains("op_str=\""))
          opStr = GetFieldValue(haystack, "op_str=\"", QuoteTail);
        else
          opStr = GetFieldValue(haystack, "op_str=");

        // General cases
        if (opStr.StartsWith("placeResultModule(100,"))
          return "demote";
        else if (opStr.StartsWith("placeResultModule(1,") || opStr.StartsWith("placeResultModule(2,"))
          return "boost";
        else if (VerticalSettings.Vertical != "wpr") {
          if (opStr.Contains("shiftScore"))
            return "demote";
          if (opStr.Contains("demote") || opStr.Contains("demotion"))
            return "demote";
        }
        else if (opStr.Contains("boost"))
          return "boost";
        else if (opStr.StartsWith("moveResultModule(-"))
          return "demote";
        else if (opStr.StartsWith("changeResultScore(-"))
          return "demote";
        else if (opStr.StartsWith("changeResultScore("))
            return "boost";

        throw new InvalidOperationException($"EnforcementStr could not be determined for {opStr} and\r\n rule name: {GetFieldValue(haystack, VerticalSettings.RuleNameHead, QuoteTail)}!");
      }

      return enfStr;
    }


    /// <summary>
    /// Get Rule Name
    /// Straight forward parsing
    /// </summary>
    /// <returns>
    /// Given a field name in old quark rule, return its value
    /// </returns>
    private string GetRuleNameForParam(string haystack) {
      var bareName = GetFieldValue(haystack, VerticalSettings.RuleNameHead, QuoteTail);
      var enforcementStr = GetIntegrityEnforcementStr(haystack);
      var name = (VerticalSettings.Vertical == "public_posts"? "posts": VerticalSettings.Vertical) +
          "_" + enforcementStr + "_" + bareName;
      return name;
    }


    // Update the indentation to match new Rules
    private string AdjustIndentation(string str) {
      return str.Replace("                   ", "       ");
    }

    public string SurroundStringWithQuotes(string str) {
      return "\"" + str + "\"";
    }


    /// <summary>
    /// `docString` 
    ///  - starts with =( or ="
    ///  - ends with )= or "=
    /// </summary>
    /// <returns>
    /// Returns desc string
    ///  - appends parenthesis around when it's multi-string
    /// isMultiLine is in correct state when input is cleaned up to not have lines like these
    ///   desc=("Boost Public posts to pos=1 for covid-19 queries."),
    /// </returns>
    private string GetRuleDescription(string haystack) {
      string needle1 = "docString=(";
      string needle2 = "docString=\"";
      var tailMark1 = ParenthesisTail;
      var tailMark2 = QuoteTail;
      bool isMultiLine = true;

      int start = haystack.IndexOf(needle1) + needle1.Length;
      if (start == (needle1.Length-1)) {
        start = haystack.IndexOf(needle2) + needle2.Length;
        isMultiLine = false;
      }

      if (!isMultiLine && (start == (needle2.Length-1)))
        throw new System.IO.InvalidDataException("Tag: docString=* not found!");

      int end = haystack.IndexOf(isMultiLine? tailMark1 : tailMark2, start + 1, haystack.Length-start-1);

      var descStr = haystack.Substring(start, end-start);

      if (isMultiLine) {
        // docString specific indentation adjustment
        descStr = AdjustIndentation(descStr);
        return '(' + descStr + ')';
      }

      return SurroundStringWithQuotes(descStr);
    }

    /// <summary>
    /// Get Action Trigger Statement
    /// formats
    /// - """ statement """
    /// - " statement "
    /// - statement_variable
    /// </summary>
    private string GetActionTriggerStatement(string haystack) {
      var needles = new string[] {
          $"actionTriggerStatement={TripleQuotes}",
          "actionTriggerStatement=\"",
          "actionTriggerStatement="};

      var tailMarks = new string[] {TripleQuotes,  QuoteTail, ","};
      int ATSType = 0;
      int start = 0;

      for (; ATSType<3; ATSType++) {
        start = haystack.IndexOf(needles[ATSType]) + needles[ATSType].Length;

        if (start >= needles[ATSType].Length)
          break;
      }

      if (ATSType == 3)
        // throw new System.IO.InvalidDataException("Tag: docString=* not found!");
        return "";

      int end = haystack.IndexOf(tailMarks[ATSType], start + 1, haystack.Length-start-1);
      // trigger statement
      var tStat = haystack.Substring(start, end-start);
      if (ATSType == 2)
        tStat = '{' + tStat  + '}';
      return tStat;
    }

    /// <summary>
    /// Get Quark Expression
    /// Straight forward
    /// </summary>
    /// <remarks>
    /// Sets
    ///  - Guard Type
    /// Returns Expression
    /// </remarks>
    private string GetQuarkExpression(string haystack, vNextRule rule) {
      string needle = "resultFilterStatement=";
      var tailMark = ",";

      int start = haystack.IndexOf(needle) + needle.Length;
      if (start == (needle.Length-1))
        throw new System.IO.InvalidDataException($"Tag: {needle} not found!");

      int end = haystack.IndexOf(tailMark, start + 1, haystack.Length-start-1);

      var quarkExpStr = haystack.Substring(start, end-start);

      var intentGuardStr = "apply_with_integrity_guard(";
      if (quarkExpStr.StartsWith(intentGuardStr)) {
        quarkExpStr = quarkExpStr.Replace(intentGuardStr, "");
        quarkExpStr = quarkExpStr.Substring(0, quarkExpStr.Length-1);
        quarkExpStr = quarkExpStr.TrimStart();
        quarkExpStr = quarkExpStr.TrimEnd(new char[] {' ', '\r', '\n'});
      }
      else {
        rule.GuardType = "IntegrityGuardType.NONE";

        if (quarkExpStr.Contains('('))
          quarkExpStr = AdjustIndentation(quarkExpStr);
      }
      
      if (ImportRefs.Add(quarkExpStr)) {
        var methodName = quarkExpStr;
        if (methodName.Contains('(')) {
          var parenthesisPosition = methodName.IndexOf('(');
          methodName = quarkExpStr.Substring(0, parenthesisPosition);
        }
      }

      return quarkExpStr;
    }

    /// <summary>
    /// Get PROD Disable Param
    /// </summary>
    /// <returns>
    /// Given a field name in old quark rule, return quark exp
    /// </returns>
    private string GetDisableParam(string haystack, bool isAutoGen) {
      var isMultiSurface = false;
      if (VerticalSettings.Vertical == "public_posts" || VerticalSettings.Vertical == "deep_dive")
        isMultiSurface = true;

      var surfaceHaystack = string.Empty;
      
      // for surface enabled rules, check if intended surface is contained
      if (isMultiSurface) {
        var surface = VerticalSettings.Vertical == "deep_dive" ? "DEEP_DIVE" : isAutoGen? "SERP" : "PUBLIC_POSTS";
        var surfaceHead =  $"SurfaceType.{surface}: QuarkImpl(";
        var surfaceTail = ')';

        // Start surface and end Surface are indices
        int startS = haystack.IndexOf(surfaceHead) + surfaceHead.Length;
        if (startS == (surfaceHead.Length-1)) {
          // Console.WriteLine("Surface not found in: " + haystack);
          throw new System.IO.InvalidDataException($"{surfaceHead} is expected in {haystack}!");
        }

        int endS = haystack.IndexOf(surfaceTail, startS + 1, haystack.Length-startS-1);
        if (endS == -1)
          throw new System.IO.InvalidDataException($"Ending marker: {surfaceTail} not found in {haystack}!");

        surfaceHaystack = haystack.Substring(startS, endS-startS);
      }
      else
        surfaceHaystack = haystack;

      string needle = VerticalSettings.DisableParamTag;
      var tailMark = QuoteTail;
      bool isExp = false;

      var status = GetFieldValue(surfaceHaystack, "status=");
      isExp = (status == "Status.EXP" || status == "2");

      if (isExp)
        needle = isMultiSurface ? "request_param_to_enable=\"": "requestParamToEnable=\"";

      if (isExp && !ContainsDoNotFilterExpRule(haystack))
        return string.Empty;

      if (surfaceHaystack.Contains("enable_ci_sspx_quark_twiddler_filter_public")) {
        // fun
      }

      int start = surfaceHaystack.IndexOf(needle) + needle.Length;
      if (start == (needle.Length-1))
        throw new System.IO.InvalidDataException($"Tag: {needle} not found: {surfaceHaystack}!");

      int end = surfaceHaystack.IndexOf(tailMark, start + 1, surfaceHaystack.Length-start-1);
      var disableParam = surfaceHaystack.Substring(start, end-start);
      var globalParam = isExp? $"{disableParam}\": \"0" : $"global:{disableParam}\": \"1";
      return "    " + SurroundStringWithQuotes(globalParam);
    }

    /// <summary>
    /// Join Action Trigger statement with Quark Expression
    /// </summary>
    private string CombineATSAndQuarkExp(string ActionTriggerStatement, string QuarkExpression) {
      if (ActionTriggerStatement == string.Empty || ActionTriggerStatement == "1")
        return QuarkExpression;
      return FStringHead + "(" + ActionTriggerStatement + ") and ({" + QuarkExpression + "})" + TripleQuotes;
    }


    /// <summary>
    /// Join Action Trigger statement with Quark Expression
    /// </summary>
    private static string GetIntegrityEnforcementTypeMap(string opStr) => opStr switch {
      "removeResult()" => "IntegrityEnforcementType.BLOCKLIST",
      "placeResultModule(100, 'result')" => "IntegrityEnforcementType.PUSH_BOTTOM",
      "placeResultModule(0, 'module')" => "IntegrityEnforcementType.BRING_TOP",
      _ => "IntegrityEnforcementType.ADDITIVE_DEMOTION",
    };

    /// <summary> 
    /// Sets
    /// - EnforcementType
    /// - OperationScript
    /// </summary>
    /// <param name="rule"> set 2 fields of this vNextRule class object </param>
    /// input examples,
    /// - resultOperationScript="moveResultModule(-5, 'result')",
    private void SetEnforcementDetails(string haystack, vNextRule rule) {
      string needle = "resultOperationScript=\"";
      var tailMark = QuoteTail;

      int start = haystack.IndexOf(needle) + needle.Length;
      if (start == (needle.Length-1)) {
        needle = needle.Substring(0, needle.Length-1);
        start = haystack.IndexOf(needle) + needle.Length;

        if (start == (needle.Length-1))
          throw new System.IO.InvalidDataException($"Tag: {needle} not found!\r\nrule string: {haystack}");

        tailMark = tailMark.Substring(1, tailMark.Length-1);
      }

      int end = haystack.IndexOf(tailMark, start + 1, haystack.Length-start-1);
      var opStr = haystack.Substring(start, end-start);

      rule.EnforcementType = GetIntegrityEnforcementTypeMap(opStr);

      if (rule.EnforcementType == "IntegrityEnforcementType.ADDITIVE_DEMOTION")
        rule.OperationScript = opStr.Contains('(') ? $"\"{opStr}\"" : opStr;
    }

    /// <summary>
    /// Was thinking to make it work a dictionary where the parsing is pretty
    /// much generic
    /// </summary>
    /// <returns>
    /// Given a field name in old quark rule, return its value
    /// </returns>
    private string GetFieldValue(string haystack, string needle, string tail = ",") {
      int start = haystack.IndexOf(needle) + needle.Length;
      if (start == (needle.Length-1))
        throw new System.IO.InvalidDataException($"Prefix: {needle} not found in {haystack}!");

      int end = haystack.IndexOf(tail, start + 1, haystack.Length-start-1);
      if (end == -1)
        throw new System.IO.InvalidDataException($"Suffix: {tail} not found in {haystack}!");

      return haystack.Substring(start, end-start);
    }

    public string GetRequestParams(string legacyRule, bool isAutoGeneratedRuleFile) {
      var ruleName = isAutoGeneratedRuleFile?GetRuleNameForParam(legacyRule):
          GetFieldValue(legacyRule, VerticalSettings.RuleNameHead, QuoteTail);

      // Get Request Params 1
      var enableParam = $"se2_integrity:enable_{RankingPlatform}_integrity_{ruleName}_enforcement\": \"1";
      
      if (isAutoGeneratedRuleFile)  // only interested in disable param for now
        enableParam = "    " + SurroundStringWithQuotes(enableParam); // + ",";
      else
        enableParam = string.Empty;

      // Get Request Params 2
      var disableParam =(isAutoGeneratedRuleFile? string.Empty : GetDisableParam(legacyRule, isAutoGeneratedRuleFile));
      var finalParams = enableParam + disableParam;
      return finalParams;
    }

    public string MigrateRule(string legacyRule) {
      var sb = new StringBuilder();
      var rule = new vNextRule();

      // Set each field, case by case
      rule.Name = GetFieldValue(legacyRule, VerticalSettings.RuleNameHead, QuoteTail);

      if (VerticalSettings.Vertical == "wpr") {
        // Rule Name
        var wprRuleName = "wpr_" + ConvertToUniformName(rule.Name);
        rule.Name = SurroundStringWithQuotes(wprRuleName);

        // Desc
        rule.Desc = GetRuleDescription(legacyRule);
        var actionTriggerStatement = GetActionTriggerStatement(legacyRule);
        var quarkExp= GetQuarkExpression(legacyRule, rule);
        rule.QuarkExpression = CombineATSAndQuarkExp(actionTriggerStatement, quarkExp);
        rule.QuarkExpression = quarkExp;
        // Set remaining 2 fields
        SetEnforcementDetails(legacyRule, rule);
      }
      else {
        Console.WriteLine(rule.Name.Substring(VerticalSettings.Vertical.Length+1));
      }

      sb.Append(rule.ToString());
      return sb.ToString();
    }

  }
}
